// Copyright 2024 Hanyu Wang
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// Following https://www.verilog.com/VerilogBNF.html

// 1. Source Text
start: description 

description: (macro_definition | timescale_directive | module)+

// 1.1 Macros
macro_definition: "`define" identifier macro_body
macro_body: /.+/

// 1.2 Timescale Directive
timescale_directive: "`timescale" time_unit "/" time_precision
time_unit: NUMBER time_identifier
time_precision: NUMBER time_identifier
time_identifier: "s" -> s | "ms" -> ms | "us" -> us | "ns" -> ns | "ps" -> ps

// 1.3 Module Declaration
module: "module" module_definition ";" module_body* "endmodule"
// TODO (fixed): this is a terrible way to define a module
// This way we can check the meta data of the module to decide the port list and parameter list
module_definition: NAME parameter_list? (port_list | empty_port_list)?

// 1.3.1 Parameter List
parameter_list: "#(" parameter_declaration ("," parameter_declaration)* ")"
parameter_declaration: parameter_type? NAME "=" parameter_value
parameter_type: "parameter" | "localparam"

// 1.3.2 Port List
empty_port_list: "(" ")"
port_list: "(" port_declaration_head ("," port_declaration_head)* ")"
port_declaration_head: port_header? (extended_port_head | simple_port_head) // This is a workaround to avoid the ambiguity of the variable numbers
extended_port_head: port_range variable_name
simple_port_head: variable_name

// 1.4 Module. i.e., what is inside a module
?module_body: always_block
            | initial_block
            | port_declaration ";" // This includes reg, wire, integer, real, time, realtime
            | parameter_assignment // This includes parameters and localparams
            | variable_assignment ";" // This includes assign
            | system_task
            | dollar_indentifier ";" // Special cases like $finish
            | module_instantiation // This includes module instantiation
            | define_parameter // This includes defparam
            | macro_definition // This includes `define

// 1.5 Module Instantiation
parameter_instance: "#" "(" parameter_instance_arguments ")"
parameter_instance_arguments: parameter_instance_argument ("," parameter_instance_argument)*
?parameter_instance_argument: signal | extended_based_number

module_instantiation: NAME parameter_instance? NAME "(" module_instance_arguments ")" ";"
module_instance_arguments: module_instance_argument ("," module_instance_argument)*
?module_instance_argument: standard_module_instance_argument | short_module_instance_argument

standard_module_instance_argument: "." NAME "(" (signal|extended_based_number)? ")"
short_module_instance_argument: signal | extended_based_number


// 1.6 Define Parameter
define_parameter: "defparam" parameter_definitions? ";"
parameter_definitions: parameter_definition ("," parameter_definition)*
parameter_definition: module_parameter "=" expression

// 2. Declarations

// 2.1 Parameter Declarations
// These are merged with module instantiations
parameter_assignment: parameter_type port_range? NAME "=" parameter_value ";"
parameter_value: expression

// 2.2 Port Declarations
port_direction: "input" -> input | "output" -> output | "inout" -> inout

// 2.3 Variable Declarations and Assignments
// the block statement is a statement block or a single statement
always_block: "always" "@" "(" event_expression ")" single_or_block_statement
event_expression: "posedge" NAME -> sequential_event
                | "negedge" NAME -> sequential_event
                | "`" NAME -> macro_event
                | variable_name
                | "*" -> combinational_event
                | event_expression event_operator event_expression

event_operator: "or" | "and"

initial_block: "initial" single_or_block_statement

// 2.4 Variable Assignments
// TODO: The challenge here is to differentiate between the non-blocking assignments and the comparison expressions
// In Verilog, the assignment operator is "=". However, the "<=" operator is used for non-blocking assignments.
variable_assignment: "assign"? expression assignment_operator expression

assignment_operator: "=" -> blocking_assignment | "<=" -> non_blocking_assignment

// 2.5 Variable Declarations

// TODO (fixed): this is a terrible way to define a port module_body
// we need to avoid the ambiguity of the variable numbers
// port_declaration: port_direction? signal_type? port_range? NAME
port_declaration: port_header? (extended_port | simple_port) // This is a workaround to avoid the ambiguity of the variable numbers

// TODO: this might cause problem if we only have signal_type without port_direction
port_header: signal_type -> header0 
        | port_direction -> header1
        | port_direction signal_type -> header2
extended_port: port_range variable_list
simple_port: variable_list

// WARNING: This should not be flattened, i.e., we should not use ? to bypass the AST level
variable_list: variable_name ("," variable_name)*

// 3. Statements
statement: variable_assignment ";"
            | conditional_statement
            | case_statement
            | system_task
            | dollar_indentifier ";"

// 3.1 Conditional Statements
// The "if" statement is used to execute a block of code if a condition is true. If the condition is false, another block of code can be executed with the "else" statement.
conditional_statement: if_statement else_if_statements? else_statement?
if_statement: "if" "(" expression ")" single_or_block_statement
else_if_statements: else_if_statement+
else_if_statement: "else if" "(" expression ")" single_or_block_statement
else_statement: "else" single_or_block_statement

// the block statement is a statement block or a single statement 
// (1) statement_block: "begin" statement+ "end"
// (2) single_statement: statement
?single_or_block_statement: statement_block | single_statement
?statement_block: "begin" statement+ "end"
single_statement: statement


// 3.3 Case Statements
case_statement: "case" "(" expression ")" case_content "endcase"
case_content: case_item+
default_case: "default" ":" statement_block
case_item: case_label ":" case_action
case_label: NAME
            | regular_number 
            | extended_based_number // You may want to support other constants or expressions as labels
?case_action: statement_block | single_statement


// 4. Declarations types
signal_type: "reg" -> reg | "wire" -> wire | "integer" -> integer | "real" -> real

// 5. Advanced system tasks
system_task: dollar_indentifier "(" [task_arguments] ")" ";"
task_arguments: expression ("," expression)*
dollar_indentifier: "$" /[a-zA-Z_][a-zA-Z0-9_]*/

// 5.1 Function calls
function_call: dollar_indentifier function_parameters?
?function_parameters: "(" expression ("," expression)* ")"

// 6. Signals

// 6.1 Signal Concatenation
array_indexing: NAME "[" expression "]" // Array indexing
array_slicing: NAME "[" expression ":" expression "]" // Array slicing
?signal: signal_base | "!" signal_base

?signal_base: variable_name
            | array_indexing
            | array_slicing
            | concatenation

// we need to avoid the ambiguity of the variable numbers, the variable name is NAME, except for the keywords in variable_blacklist
variable_name: NAME | ESCAPED_STRING

variable_blacklist: signal_type | port_direction

// 6.2 Module parameters
module_parameter: NAME "." NAME

// 7. Ranges
port_range : "[" expression ":" expression "]"

// 8. Expressions
expression: "`" NAME -> macro_usage
// 8.0.0 Constants, these are fine to be flattened
            | NAME -> variable_expression
            | ESCAPED_STRING -> variable_expression
            | string
            | regular_number
            | based_number
            | extended_based_number // You may want to support other constants or expressions
// 8.0.1 More signals
            | "{" expression ("," expression)* "}" -> array_concat // Concatenation is treated as an expression
            | "{" expression "{" expression "}" "}" -> array_replicate // Repeated concatenation is treated as an expression
            | expression "[" expression "]" -> array_index // Array indexing is treated as an expression
            | expression "[" expression ":" expression "]" -> array_slice // Array slicing is treated as an expression
            | "$" NAME function_parameters -> function_call // Function calls are treated as expressions
// 8.1 Operators
// Operators are used to perform operations on variables and values.
// note that we cannot separate the operators into different levels, as the operators are not strictly ordered
// Reference: https://documentation-rp-test.readthedocs.io/en/latest/tutorfpga04.html
//
// TODO: double check the precedence of the reduction operators
//
// 8.1.8 Conditional Operator
// This operator has the next highest precedence
            | expression "?" expression ":" expression -> conditional_expression
// 8.1.7 Logical Operators
// These operators have the next highest precedence
            | expression "&&" expression -> binary_and // Logical AND
            | expression "||" expression -> binary_or // Logical OR
// 8.1.6 Bitwise Operators
// These operators have the next highest precedence 
            | expression "&" expression -> binary_bitand // Bitwise AND
            | expression "^" expression -> binary_xor // Bitwise XOR
            | expression "^~" expression -> binary_xnor // Bitwise XNOR
            | expression "~^" expression -> binary_xnor // Bitwise XNOR
            | expression "|" expression -> binary_bitor // Bitwise OR
// 8.1.5 Equivalence Operators
// These operators have the next highest precedence
            | expression "==" expression -> binary_eq // Equal
            | expression "!=" expression -> binary_neq // Not equal
            | expression "===" expression -> binary_eq_ext // Case equality
            | expression "!==" expression -> binary_neq_ext // Case inequality
// 8.1.4 Comparison Operators
// These operators have the next highest precedence
            | expression "<" expression -> binary_lt // Less than
            | expression ">" expression -> binary_gt // Greater than
            | expression "<=" expression -> binary_leq // Less than or equal
            | expression ">=" expression -> binary_geq // Greater than or equal
// 8.1.3 Shift Operators
// These operators have the next highest precedence
            | expression ">>" expression -> binary_rshift // Shift right
            | expression ">>>" expression -> binary_rshift_ext // Shift right with sign extension
            | expression "<<" expression -> binary_lshift // Shift left
            | expression "<<<" expression -> binary_lshift_ext // Shift left with sign extension
// 8.1.2 Binary Plus and Minus
// These operators have the next highest precedence
            | expression "+" expression -> binary_add // Addition
            | expression "-" expression -> binary_sub // Subtraction
// 8.1.1 Unary Operators
// These operators has the second highest precedence
            | "+" expression -> unary_pos // Unary plus
            | "-" expression -> unary_neg // Unary minus
            | "!" expression -> unary_not // Logical NOT
            | "~" expression -> unary_inv // Bitwise NOT
// 8.1.1.1 Unitary Reduction Operators
// These operators have the highest precedence
            | "&" expression -> unary_and // Bitwise AND reduction
            | "|" expression -> unary_or // Bitwise OR reduction
            | "^" expression -> unary_xor // Bitwise XOR reduction
            | "~&" expression -> unary_nand // Bitwise NAND reduction
            | "~|" expression -> unary_nor // Bitwise NOR reduction
            | "~^" expression -> unary_xnor // Bitwise XNOR reduction
// 8.1.9 Concatenation and Repetition
// These operators' precedence does not matter, because they will not be used in the same expression

// 8.0.3 Parentheses
// Parentheses are used to group expressions
// These operators have the highest precedence
            | "(" expression ")"
// 8.2 Concatenation and Repetition
concatenation: "{" expression ("," expression)* "}"
repeated_concatenation: "{" expression "{" expression "}" "}"

// special characters
string: /"[^"]*"/  // Captures a sequence of characters within double quotes

// 9. Numbers
based_number: /'[bdh][0-9a-fA-F_]+/
extended_based_number: /([0-9]*)'[bdhoBDHO][0-9a-fA-F_xXzZ]+/
regular_number: /(?<![\d'])\d+(?![\d'bhd])/

// 10. General
?identifier: NAME
            | ESCAPED_IDENTIFIER

// Lark
ESCAPED_IDENTIFIER: /\\([^\s]+)/
COMMENT: "//" /[^\n]*/ NEWLINE
INLINE_COMMENT: "(*" /[^\n]*/ "*)"
NEWLINE: "\n"
MULTILINE_COMMENT: /\/\*(\*(?!\/)|[^*])*\*\//

%import common.CNAME -> NAME
%import common.NUMBER
%import common.ESCAPED_STRING
%import common.WS

%ignore WS
%ignore COMMENT
%ignore MULTILINE_COMMENT
%ignore NEWLINE
%ignore INLINE_COMMENT
